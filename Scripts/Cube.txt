class Cube : CarryActor
{
	Sector activesector;
	double rollvel, pitchvel;
	double bounceangle;

	Default
	{
		//$Category Portal/Cubes
		//$Sprite "UNKNB0"
		+SOLID
		+NOBLOOD
		+NOTAUTOAIMED
		+PUSHABLE
		+CANPASS
		+SHOOTABLE
		+ALLOWBOUNCEONACTORS
		+BOUNCEONACTORS
		+MBFBOUNCER
		+BOUNCEAUTOOFF
		+CANBOUNCEWATER
		-NODAMAGE
		Health 100;
		Height 51;
		Radius 33;
		Mass 111;
		Scale 0.45;
		MaxDropoffHeight 26;
		MaxStepHeight 26;
		BounceType "Grenade";
		BounceFactor 0.05;
		BounceSound "cube/bounce";
		WallBounceSound "cube/bounce";
		DamageFactor 0.0;
		DamageFactor "Slime", 10.0;
	}

	States
	{
		Spawn:
			UNKN A 1;
			Loop;
		Death:
			Goto Fizzle;
	}

	override void BeginPlay()
	{
		ChangeStatNum(Thinker.STAT_USER);
		Super.BeginPlay();
	}

	override void Tick()
	{
		bounceangle = angle;

		Super.Tick();

		angle = bounceangle; // Undo angle change made by AngelFromVel call in internal bouncing code

		if (bDormant) { return; }

		Utilities.CheckFizzle(self);

		if (master)
		{
//			pitch = master.pitch;
			roll = master.roll;
			return;
		}

//		pitchvel = vel.z * sin(pitch);

		Vector2 relmove = RotateVector(vel.xy, -angle);
//		rollvel = relmove.y;

		if (pos.z <= floorz + zoffset || bOnMobj)
		{ 
			if (vel.length() < 2.0 || bOnMobj)
			{
				vel = (0, 0, 0);
				pitchvel = 0;
				rollvel = 0;
				A_SetSize(Default.Radius * scale.x, Default.Height * scale.y, true); // Reset the size, just in case a portal left it shrunken
			}
			else
			{
				vel.xy *= 0.4;
				pitchvel *= 0.4;
				rollvel *= 0.4;
			}

			if (master && (master is "Launcher")) { master = null; }
		}
		else if (pos.z >= ceilingz - zoffset) { vel.z *= -1.2; }
		else
		{
			pitch -= pitchvel;
			roll -= rollvel;

			if (!master || !(master is "Launcher"))
			{
				if (vel.z > 0) { vel *= 0.8; }
				else { vel *= 1.00125; }
			}
		}

		if (master && (master is "PlayerPawn"))
		{
			pitch = 0; // Temporary until I can fix the "physics"
			roll = 0;
		}

//		zoffset = abs(radius * sin(pitch) * sin(roll)) + abs((height / 2) * cos(pitch) * cos(roll));
		zoffset = 0;

		SetOrigin((pos.xy, max(pos.z, floorz + zoffset)), true);
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (passive && other && other is "PlayerPawn")
		{
//			if (Distance2D(other) > radius + other.radius / 4) { return false; }
		}

		return true;
	}
}

class LaserCube : Cube
{
	Actor lasersource, interior;
	bool laserhit;

	Default
	{
		//$Title Laser Cube
	}

	override void PostBeginPlay()
	{
		while (!interior) { interior = Spawn("LaserCubeInterior", pos); }
		while (!lasersource) { lasersource = Spawn("LaserSpot", pos); }

		interior.master = self;

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (lasersource)
		{
			lasersource.master = self;
//			lasersource.SetOrigin(pos + (radius * 1.4 * cos(angle), radius * 1.4 * sin(angle), height * 0.5), true);
			lasersource.SetOrigin(pos + (0, 0, height / 2), false);
			lasersource.angle = angle;

			if (laserhit)
			{
				lasersource.SetStateLabel("Active");
				A_AttachLight("LaserLight", DynamicLight.PointLight, 0xDD0000, int(radius), int(radius), DynamicLight.LF_ATTENUATE, (0, 0, height / 2));
				if (interior.alpha < 0.7) { interior.alpha = min(0.7, interior.alpha + 0.05); }
			}
			else
			{
				lasersource.SetStateLabel("Inactive");
				A_RemoveLight("LaserLight");
				if (interior.alpha > 0.35) { interior.alpha = max(0.35, interior.alpha - 0.05); }
			}
		}

		laserhit = false;

		Super.Tick();
	}	

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (inflictor is "LaserBeam" && source != self)
		{
			laserhit = true;
		}

		return 0;
	}
}

class LaserCubeInterior : Actor
{
	Default
	{
		+NOINTERACTION
		Scale 0.45;
		Renderstyle "Translucent";
		Alpha 0.7;
		Species "Laser";
	}

	override void Tick()
	{
		if (master)
		{
			angle = master.angle;
			pitch = master.pitch;
			roll = master.roll;
			SetOrigin(master.pos, true);
			return;
		}
		else { Destroy(); }

		Super.Tick();
	}

	States
	{
		Spawn:
			UNKN A -1;
			Stop;
	}
}