class Cube : Actor
{
	Sector activesector;
	double rollvel, pitchvel, zoffset;
	double bounceangle;

	Default
	{
		//$Category Portal/Objects
		//$Sprite "UNKNB0"
		+SOLID
		+NOBLOOD
		+NOTAUTOAIMED
		+PUSHABLE
		+CANPASS
		+SHOOTABLE
		+ALLOWBOUNCEONACTORS
		+BOUNCEONACTORS
		+MBFBOUNCER
		+BOUNCEAUTOOFF
		+CANBOUNCEWATER
		Height 23;
		Radius 15;
		Health 100;
		Mass 50;
		Scale 0.45;
		MaxDropoffHeight 26;
		MaxStepHeight 26;
		BounceType "Grenade";
		BounceFactor 0.05;
		BounceSound "cube/bounce";
		WallBounceSound "cube/bounce";
		DeathSound "cube/fizzle";
		DamageFactor 0.0;
		DamageFactor "Slime", 10.0;
	}

	States
	{
		Spawn:
			UNKN A 1;
			Loop;
		Death:
			UNKN A 1 A_Scream();
		Fizzle:
			UNKN A 1 Fizzle();
			Loop;
	}

	override void BeginPlay()
	{
		ChangeStatNum(Thinker.STAT_USER);
	}

	override void Tick()
	{
		bounceangle = angle;

		Super.Tick();

		angle = bounceangle; // Undo angle change made by AngelFromVel call in internal bouncing code

		if (bDormant) { return; }

		if (!InStateSequence(CurState, FindState("Death")))
		{
			if (waterlevel) { SetStateLabel("Death"); return; } // Needs to be smarter to detect if it's slime or normal water.  Can't check current 3D floor in ZScript right now, apparently?
			if (pos.z == floorz && floorpic == TexMan.CheckForTexture("F_SKY1", TexMan.Type_Any)) { SetStateLabel("Death"); return; } 

			Line current = CurrentLine();
			if (current)
			{
				for (int i = 0; i < 2; i++)
				{
					Side HitSide = current.sidedef[i];

					if (HitSide)
					{
						TextureID tex = HitSide.GetTexture(Side.mid);

						if (tex && TexMan.GetName(tex) ~== "EMANGRIL")
						{
							if (HitSide.flags & Side.WALLF_WRAP_MIDTEX || current.flags & Line.ML_WRAP_MIDTEX) { SetStateLabel("Death"); return; } // If it's floor-to-ceiling, skip checks
							else
							{
								double yoffset = HitSide.GetTextureYOffset(1);
								Vector2 size = TexMan.GetScaledSize(tex);

								if (current.flags & Line.ML_DONTPEGBOTTOM) // Lower unpegged
								{
									if (pos.z > floorz + yoffset - 24.0 && pos.z + height < floorz + yoffset + size.y + 24.0)
									{
										SetStateLabel("Death"); return; 
									}
								}
								else
								{
									if (pos.z > ceilingz + yoffset + 24.0 && pos.z + height < ceilingz + yoffset - size.y - 24.0)
									{
										SetStateLabel("Death"); return; 
									}
								}
							}
						}
					}
				}
			}
		}

		if (master)
		{
//			pitch = master.pitch;
			roll = master.roll;
			return;
		}

//		pitchvel = vel.z * sin(pitch);

		Vector2 relmove = RotateVector(vel.xy, -angle);
//		rollvel = relmove.y;

		pitch = 0; // Temporary until I can fix the "physics"
		roll = 0;

		if (pos.z <= floorz + zoffset || bOnMobj)
		{ 
			if (vel.length() < 2.0 || bOnMobj)
			{
				vel = (0, 0, 0);
				pitchvel = 0;
				rollvel = 0;
				A_SetSize(Default.Radius, Default.Height, true); // Reset the size, just in case a portal left it shrunken
			}
			else
			{
				vel.xy *= 0.4;
				pitchvel *= 0.4;
				rollvel *= 0.4;
			}

			if (master && (master is "Launcher")) { master = null; }

			SetPitchRoll(self);
		}
		else if (pos.z >= ceilingz - zoffset) { vel.z *= -1.2; }
		else
		{
			pitch -= pitchvel;
			roll -= rollvel;

			if (!master || !(master is "Launcher"))
			{
				if (vel.z > 0) { vel *= 0.8; }
				else { vel *= 1.00125; }
			}
		}

//		zoffset = abs(radius * sin(pitch) * sin(roll)) + abs((height / 2) * cos(pitch) * cos(roll));
		zoffset = 0;

		SetOrigin((pos.xy, max(pos.z, floorz + zoffset)), true);
	}

	// Handling for terrain-based pitch/roll calculations...
	static double SetPitchRoll(Actor mo, bool cube = true, bool force = false)
	{
		if (!mo) { return 0; }

		double xoffset = 0;
		double yoffset = 0;

		double testwidth = mo.radius + yoffset;
		double testlength;

		if (!testlength) { testlength = mo.radius + xoffset; }

		// Account for current pitch/roll when measuring corner heights
		testwidth *= abs(cos(mo.roll));
		testlength *= abs(cos(mo.pitch));

		testlength = max(testlength, 1);
		testwidth = max(testwidth, 1);

		double points[4], minz = 0x7FFFFFFF, maxz = -0x7FFFFFFF;

		// Get the relative z-height at the four corners of the actor
		points[0] = mo.GetZAt(testlength, testwidth);
		points[1] = mo.GetZAt(testlength, -testwidth);
		points[2] = mo.GetZAt(-testlength, testwidth);
		points[3] = mo.GetZAt(-testlength, -testwidth);

		for (int i = 0; i < 4; i++)
		{
			double maxstep = mo.MaxStepHeight;
			double maxdrop = mo.MaxDropoffHeight;

			if (points[i] > mo.pos.z + maxstep) { points[i] = 0; } // Ignore the point if you can't climb that high
			if (points[i] < mo.pos.z - maxdrop) { points[i] = 0; } // Ignore the point if it's a dropoff
			else { points[i] -= mo.floorz; }
		}

		// Use those values to calculate the pitch.roll amounts
		double pitchinput = (points[0] + points[1]) / 2 - (points[2] + points[3]) / 2;
		double rollinput = (points[1] + points[3]) / 2 - (points[0] + points[2]) / 2;

		pitchinput = atan(pitchinput / (testlength * 2));
		rollinput = atan(rollinput / (testwidth * 2));

		if (cube)
		{
			// It's a cube.  Stop rolling if it's on a flat face...
			if (int(mo.pitch) % 90 == int(-pitchinput)) { pitchinput = -mo.pitch; }
			if (int(mo.roll) % 90 == int(rollinput)) { rollinput = mo.roll; }
		}

		// Interpolate to the new values
		if (force || level.time && level.time < 15)
		{
			mo.pitch = -pitchinput;
			mo.roll = rollinput;
		}
		else
		{
			int pstep = 1; //max(1, int(abs(mo.pitch % 90 + pitchinput) / 10));
			int rstep = 1; //max(1, int(abs(mo.roll % 90 - rollinput) / 10));

			if (mo.pitch > -pitchinput) { mo.pitch = max(mo.pitch - pstep, -pitchinput); }
			else if (mo.pitch < -pitchinput) { mo.pitch = min(mo.pitch + pstep, -pitchinput); }

			if (mo.roll > rollinput) { mo.roll = max(mo.roll - rstep, rollinput); }
			else if (mo.roll < rollinput) { mo.roll = min(mo.roll + rstep, rollinput); }
		}

		// Return the amount that you need to adjust the model z position by in order to keep it looking like it's actually on the ground
		double deltaz = testlength * sin(abs(mo.pitch)) + testwidth * sin(abs(mo.roll));

		return deltaz; 
	}

	Line CurrentLine()
	{
		// Find the line that this actor's centerpoint is closest to
		Line linedef;
		double dist;

		BlockLinesIterator it = BlockLinesIterator.Create(self);

		While (it.Next())
		{
			Line current = it.curline;

			// Discard lines that definitely don't cross the actor's center point
			if (
				(current.v1.p.x > pos.x + radius && current.v2.p.x > pos.x + radius) ||
				(current.v1.p.x < pos.x - radius && current.v2.p.x < pos.x - radius) ||
				(current.v1.p.y > pos.y + radius && current.v2.p.y > pos.y + radius) ||
				(current.v1.p.y < pos.y - radius && current.v2.p.y < pos.y - radius) 
			) { continue; }

			// Find the line that is closest based on proximity to end vertices
			double curdist = (current.v1.p - pos.xy + current.v2.p - pos.xy).Length();
			if (!linedef || curdist <= dist)
			{
				linedef = current;
				dist = curdist;
			}
		}

		return linedef;
	}

	void Fizzle()
	{
		if (master && PortalPlayer(master))
		{
			PortalPlayer(master).DragTarget = null;
			master = null;
		}

		bSolid = false;
		bInvulnerable = true;
		bNoTarget = true;
		bMBFBouncer = false;

		alpha = max(alpha - 0.05, 0);
		gravity = 0.1;
		vel = (0, 0, 0.5);
		scale *= 1.01;

		A_SetRenderStyle(alpha, STYLE_TranslucentStencil);

		let spark = A_SpawnProjectile("SingleSpark", FRandom(-Height / 2, Height / 2), FRandom(-Radius, Radius), FRandom(0, 360), CMF_AIMDIRECTION, -90 + FRandom(-45, 45));
		spark.master = self;

		if (alpha <= 0) { Destroy(); }
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (passive && other && other is "PlayerPawn")
		{
//			if (Distance2D(other) > radius + other.radius / 4) { return false; }
		}

		return true;
	}
}

class LaserCube : Cube
{
	Actor lasersource, interior;
	bool laserhit;

	Default
	{
		//$Category Portal/Objects
		//$Title Laser Cube
	}

	override void PostBeginPlay()
	{
		while (!interior) { interior = Spawn("LaserCubeInterior", pos); }
		while (!lasersource) { lasersource = Spawn("LaserSpot", pos); }

		interior.master = self;

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		if (lasersource)
		{
			lasersource.master = self;
			lasersource.SetOrigin(pos + (radius * 1.4 * cos(angle), radius * 1.4 * sin(angle), height * 0.5), true);
			lasersource.angle = angle;

			if (laserhit)
			{
				lasersource.SetStateLabel("Active");
				if (interior.alpha < 1.0) { interior.alpha = min(1.0, interior.alpha + 0.05); }
			}
			else
			{
				lasersource.SetStateLabel("Inactive");
				if (interior.alpha > 0.7) { interior.alpha = max(0.0, interior.alpha - 0.05); }
			}
		}

		laserhit = false;

		Super.Tick();
	}	

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (inflictor is "LaserBeam")
		{
			laserhit = true;
		}

		return 0;
	}
}

class LaserCubeInterior : Actor
{
	Default
	{
		+NOINTERACTION
		Scale 0.45;
		Renderstyle "Translucent";
		Alpha 0.7;
	}

	override void Tick()
	{
		if (master)
		{
			angle = master.angle;
			pitch = master.pitch;
			roll = master.roll;
			SetOrigin(master.pos, true);
			return;
		}
		else { Destroy(); }

		Super.Tick();
	}

	States
	{
		Spawn:
			UNKN A -1;
			Stop;
	}
}