class OverlayItem
{
	Actor mo;
	String icon;
	double alpha;
}

class OverlayHandler : EventHandler
{
	Array<OverlayItem> OverlayItems;

	override void WorldThingDestroyed(WorldEvent e)
	{
		int i = FindItem(e.Thing);

		if (i < OverlayItems.Size())
		{
			OverlayItems.Delete(i, 1);
			OverlayItems.ShrinkToFit();
		}
	}

	uint FindItem(Actor mo) // Helper function to find a thing in a child class (Used in place of CompassItems.Find(mo) since the mo is nested in a CompassIcon object
	{
		for (int i = 0; i < OverlayItems.Size(); i++)
		{
			if (OverlayItems[i] && OverlayItems[i].mo == mo) { return i; }
		}
		return OverlayItems.Size();
	}

	void AddItem(Actor thing, String iconName = "")
	{
		if (!thing) { return; }

		int i = FindItem(thing);
		if (i < OverlayItems.Size()) // If it's already there, just update the icon
		{
			OverlayItems[i].icon = iconName;
		}
		else
		{
			OverlayItem item = New("OverlayItem");
			item.mo = thing;
			item.icon = iconName;
			item.alpha = 0.0;

			OverlayItems.Push(item);
		}
	}


	static void Add(Actor thing, String iconName = "", int actorTID = 0)
	{
		if (iconName == "") { return; }

		if (!thing || actorTID)
		{
			if (actorTID)
			{
				let it = level.CreateActorIterator(actorTID, "Actor");
				Actor mo;

				while (mo = Actor(it.Next()))
				{
					Add(mo, iconName); // Add each thing that has a matching TID
				}
			}

			return; // If no thing was passed, silently fail here
		} 

		OverlayHandler handler = OverlayHandler(EventHandler.Find("OverlayHandler"));
		if (!handler) { return; } // If no handler was found (somehow), silently fail

		handler.AddItem(thing, iconName);
	}

	static void Remove(Actor thing)
	{
		if (!thing) { return; } // If no thing was passed, silently fail

		OverlayHandler handler = OverlayHandler(EventHandler.Find("OverlayHandler"));
		if (!handler) { return; }

		int i = handler.FindItem(thing);

		if (i < handler.OverlayItems.Size())
		{
			handler.OverlayItems[i].Destroy();
			handler.OverlayItems.Delete(i, 1);
			handler.OverlayItems.ShrinkToFit();
		}
	}

	override void RenderUnderlay( RenderEvent e )
	{
		PlayerInfo p = players[consoleplayer];

		if (!p || !p.mo || (p.cheats & CF_CHASECAM) || automapactive) { return; }

		for (int i = 0; i < OverlayItems.Size(); i++)
		{
			Actor mo = OverlayItems[i].mo;
			if (!mo) continue;

			double dist = p.mo.Distance3D(mo);
			if (dist > 256) { continue; }

			Vector3 worldpos = e.viewpos + level.Vec3Diff(e.viewpos, mo.pos); // World position of object, offset from viewpoint
			Vector3 screenpos = PortalCoordUtil.WorldToScreen(worldpos, e.viewpos, e.viewpitch, e.viewangle, e.viewroll, p.fov); // Translate that to the screen, using the viewpoint's info

			if (screenpos.z > 1 || screenpos.z < -1) { continue; } // If the coordinates are off the screen, then skip drawing this item

			Vector2 drawpos = PortalCoordUtil.ToViewport(screenpos);

			TextureID image = TexMan.CheckForTexture(OverlayItems[i].icon, TexMan.Type_Any);

			Vector2 dimensions = TexMan.GetScaledSize(image);
			dimensions /= dist / 320 * p.fov / 90; // Scale with fov to account for zooming

			color clr = 0xDE1B15;
			double alpha = max(1.0 - (dist - 256) / 256, 0);

			screen.DrawTexture (image, false, drawpos.x, drawpos.y, DTA_DestWidthF, dimensions.x, DTA_DestHeightF, dimensions.y, DTA_AlphaChannel, true,/* DTA_FillColor, clr & 0xFFFFFF, */DTA_Alpha, alpha);
		}
	}
}