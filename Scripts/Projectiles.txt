class Pellet : Actor
{
	Default
	{
		Projectile;		
		+BOUNCEONACTORS
		+DONTBOUNCEONSHOOTABLES
		+FORCEXYBILLBOARD
		Radius 10;
		Height 20;
		Speed 2.0;
		Damage 100;
		BounceType "Hexen";
		BounceCount 5;
		BounceFactor 1.0;
		RenderStyle "Add";
		Scale 0.4;
		Alpha 0.35;
		SeeSound "weapons/plasmaf";
		BounceSound "vile/firestrt";
		DeathSound "weapons/plasmax";
		Obituary "%o was killed by an energy pellet.";
	}

	States
	{
		Spawn:
			PLSS A 6;
			Loop;
		Death:
			PLSE ABCDE 4 Bright A_Explode(damage, 32);
			Stop;
	}

	override void BeginPlay()
	{
		ChangeStatNum(Thinker.STAT_USER);
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		Actor shell;

		While (!shell) { shell = Spawn("PelletShell", pos); }
		shell.master = self;
	}
}

class PelletShell : Actor
{
	Actor light, flare;

	Default
	{
		+NOGRAVITY;
		+NOINTERACTION;
		Radius 0;
		Height 0;
		RenderStyle "Add";
		Alpha 0.4;
		Scale 0.8;
	}
	States
	{
		Spawn:
			UNKN A 1;
			Loop;
		Explode:
			UNKN A 35;
			Stop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		while (!AlphaLight(light)) { light = Spawn("AlphaLight", pos); }
		light.master = master;
		AlphaLight(light).maxradius = 16.0;
		AlphaLight(light).clr = Color(0, 191, 255);
		light.alpha = 1.0;
		AlphaLight(light).bAttenuate = true;

		while (!flare) { flare = Spawn("Flare", pos); }
		flare.master = self;
	}

	override void Tick()
	{
		Super.Tick();

		if (master)
		{
			SetOrigin(master.pos, false);

			if (light && AlphaLight(light)) { AlphaLight(light).maxradius = 16.0 + 8 * sin(level.time * 4); }

			if (InStateSequence(master.CurState, master.FindState("Death")))
			{
				master = null;
				AlphaLight(light).maxradius = 32.0;
				SetStateLabel("Explode");
			}
		}
		else
		{
			Scale *= 1.2;
			A_FadeOut(0.05);
			if (light)
			{
				light.alpha = max(light.alpha - 0.1, 0);
				if (light.alpha <= 0) { light.Destroy(); }
			}
		}
	}

	override void OnDestroy()
	{
		if (light) { light.Destroy(); }
	}
}


class Flare : Actor
{
	Actor light;

	Default
	{
		+NOGRAVITY;
		+NOINTERACTION;
		Radius 0;
		Height 0;
		RenderStyle "Add";
		Alpha 0.4;
		Scale 0.35;
	}
	States
	{
		Spawn:
			FLAS H 1;
			Loop;
	}

	override void Tick()
	{
		Super.Tick();

		if (master)
		{
/*
			SetOrigin(master.pos, false);

			if (players[consoleplayer].mo)
			{
				double amt = 1.0 - abs(pos.z - players[consoleplayer].mo.pos.z) / 128;

				scale.y = clamp(amt * Default.scale.y, 0.05, Default.scale.y);
				alpha = clamp(amt * Default.alpha, 0.1, Default.alpha);
			}
*/
		}
		else
		{
			Destroy();
		}
	}
}

class LaserBeam : Actor
{
	Default
	{
		+NOGRAVITY
		+NOINTERACTION
		+NOBLOCKMAP
		+BRIGHT
		Radius 0;
		Height 0;
		RenderStyle "Add";
		RenderRadius 2048.0;
	}

	States
	{
		Spawn:
			TNT1 A 0;
			UNKN A 1;
			Stop;
	}


	override void Tick()
	{
		if (!master) { Destroy(); }

		Super.Tick();
	}
}

class LaserBeamBlue : LaserBeam
{
	Default
	{
		Alpha 0.25;
	}
}

class LaserLight : Actor
{
	Default
	{
		+INVISIBLE
		+NOINTERACTION
	}

	States
	{
		Spawn:
			UNKN A 0;
			UNKN A 1 Light("SmallRedLight");
			Stop;
	}
}

class LaserSpot : Actor
{
	LaserFindHitPointTracer hittracer;
	Actor hitspot, flare, flare2;

	Default
	{
		+NOGRAVITY
		+NOINTERACTION
		+NOBLOCKMAP
		+INVISIBLE
		Species "Laser";
		Radius 0;
		Height 0;
	}

	States
	{
		Spawn:
		Inactive:
			UNKN A 1
			{
				if (hitspot) { hitspot.Destroy(); }
				if (flare) { flare.Destroy(); }
				if (flare2) { flare2.Destroy(); }
			}
			Loop;
		Active:
			UNKN A 1 A_FireLaser();
			Loop;
	}

	override void PostBeginPlay()
	{
		hittracer = new("LaserFindHitPointTracer");

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		Super.Tick();

		if (master)
		{
			pitch = master.pitch;
			if (master is "PortalSpot" && Distance3D(master) > 32.0) { Destroy(); }
		}
	}

	void A_FireLaser(int damage = 3, sound snd = "laser")
	{
		DoTrace(self, angle, 2048, pitch, 0, 0, hittracer);
		DrawLaser(hittracer.Results, damage:damage);
	}

	action void DoTrace(Actor origin, double angle, double dist, double pitch, int flags, double zoffset, LaserFindHitPointTracer thistracer)
	{
		if (!thistracer) { return; }

		if (!origin) { origin = self; }

		thistracer.skipspecies = origin.species;
		thistracer.skipactor = origin;

		Vector3 tracedir = (cos(angle) * cos(pitch), sin(angle) * cos(pitch), -sin(pitch));
		thistracer.Trace(origin.pos + (0, 0, zoffset), origin.CurSector, tracedir, dist, 0);
	}

	void DrawLaser(TraceResults traceresults, Class<Actor> spawnclass = "LaserBeam", Class<Actor> puffclass = "LaserHit", int damage = 3, double sparsity = 3.0)
	{
		if (!traceresults) { return; }

		double distanceoffset = 24.0;

		// Light flare

		if (!flare2 && (!master || !(master is "LaserCube" || master is "PortalSpot"))) { flare2 = Spawn("Flare", pos + traceresults.HitVector * 12.0, ALLOW_REPLACE); }
		if (flare2)
		{
			flare2.master = self;
			flare2.alpha = 0.9;
			flare2.SetOrigin(pos + traceresults.HitVector * 12.0, false);
		}

		Actor mo;

		//Laser beam
		mo = Spawn(spawnclass, pos + traceresults.HitVector * ((traceresults.Distance + distanceoffset) / 2 - distanceoffset + 4), ALLOW_REPLACE);
		if (mo)
		{
			mo.master = self;
			mo.target = self;
			mo.pitch = pitch - 90;
			mo.angle = angle;
			mo.scale.x = FRandom(0.9, 1.2);
			mo.scale.y = (traceresults.Distance + distanceoffset) * 2.175;
		}

		if (!hitspot) { hitspot = Spawn("LaserHitMarker", traceresults.HitPos - traceresults.HitVector * Radius, ALLOW_REPLACE); }
		if (hitspot)
		{
			hitspot.master = self;
			hitspot.SetOrigin(traceresults.HitPos - traceresults.HitVector * Radius, false);
		}

		if (traceresults.HitActor)
		{
			traceresults.HitActor.DamageMobj(mo, self, damage, "Laser");
			if (traceresults.HitActor is "LaserCube" || traceresults.HitActor is "LaserTrigger") { return; }
		}

		// Sparkles
		if (puffclass != "") { Actor puff = Spawn(puffclass, traceresults.HitPos, ALLOW_REPLACE); }

		// Light flare
		if (!flare) { flare = Spawn("Flare", traceresults.HitPos, ALLOW_REPLACE); }
		if (flare)
		{
			flare.master = mo;
			flare.alpha = 0.7 + FRandom(-0.2, 0.2);
			flare.scale = flare.Default.scale * FRandom(0.2, 0.5);
			flare.SetOrigin(traceresults.HitPos, false);
		}
	}
}

class LaserHitMarker : Actor
{
	Default
	{
		Radius 1;
		Height 1;
		+NOGRAVITY
		+NOINTERACTION
		+INVISIBLE
	}

	States
	{
		Spawn:
			AMRK A -1;
			Stop;
	}

	override void BeginPlay()
	{
		ChangeStatNum(Thinker.STAT_USER);
	}

	override void Tick()
	{
		if (!master) { Destroy(); }
		else
		{
			angle = master.angle;
			pitch = master.pitch;
		}

		Super.Tick();
	}

	override void OnDestroy()
	{
		if (Alternative) { Alternative.Destroy(); }
	}
}

class LaserEmitter : LaserSpot
{
	Default
	{
		//$Category Portal/Objects
		//$Title Laser Emitter
		-INVISIBLE
		Scale 1.2;
	}

	States
	{
		Inactive:
			UNKN A 1
			{
				A_StopSound(CHAN_6);
			}
			Goto Super::Inactive;
		Active:
			UNKN A 1
			{
				A_FireLaser();
				A_PlaySound("laser/loop", CHAN_6, 0.05, true, ATTN_STATIC);
			}
			Loop;
	}
}

class LaserEmitterBlue : LaserSpot
{
	BridgeFindHitPointTracer hittracer2;

	States
	{
		Inactive:
			UNKN A 1
			{
				A_StopSound(CHAN_6);
			}
			Goto Super::Inactive;
		Spawn:
		Active:
			UNKN A 1
			{
				A_FireGuideLaser();
				A_PlaySound("laser/loop", CHAN_6, 0.0125, true, ATTN_STATIC);
			}
			Loop;
	}

	override void PostBeginPlay()
	{
		hittracer2 = new("BridgeFindHitPointTracer");

		Super.PostBeginPlay();
	}

	void A_FireGuideLaser()
	{
		DoTrace(self, angle, 2048, pitch, TRF_THRUACTORS, 0, hittracer2);
		DrawGuideLaser(hittracer2.Results);
	}

	action void DoTrace(Actor origin, double angle, double dist, double pitch, int flags, double zoffset, BridgeFindHitPointTracer thistracer)
	{
		if (!thistracer) { return; }

		if (!origin) { origin = self; }

		Vector3 tracedir = (cos(angle) * cos(pitch), sin(angle) * cos(pitch), -sin(pitch));
		thistracer.Trace(origin.pos + (0, 0, zoffset), origin.CurSector, tracedir, dist, 0);
	}

	void DrawGuideLaser(TraceResults traceresults, Class<Actor> spawnclass = "LaserBeamBlue", Class<Actor> puffclass = "", int damage = 0, double sparsity = 3.0)
	{
		if (!traceresults) { return; }

		double distanceoffset = 24.0;

		Actor mo;

		//Laser beam
		mo = Spawn(spawnclass, pos + traceresults.HitVector * ((traceresults.Distance + distanceoffset) / 2 - distanceoffset + 4), ALLOW_REPLACE);
		if (mo)
		{
			mo.master = self;
			mo.target = self;
			mo.pitch = pitch - 90;
			mo.angle = angle;
			mo.scale.x = FRandom(0.9, 1.2);
			mo.scale.y = (traceresults.Distance + distanceoffset) * 2.175;
		}
	}
}

class BridgeSpot : Actor
{
	BridgeFindHitPointTracer hittracer;
	Actor hitspot;

	Default
	{
		+NOGRAVITY
		+NOINTERACTION
		+NOBLOCKMAP
		+INVISIBLE
		Species "Bridge";
		Radius 0;
		Height 0;
	}

	States
	{
		Spawn:
		Inactive:
			UNKN A 1 A_RemoveChildren(true, RMVF_EVERYTHING);
			Loop;
		Active:
			UNKN A 1;
			UNKN A 1 A_FireBeam();
		ActiveLoop:
			UNKN A 1;
			Loop;
	}

	override void PostBeginPlay()
	{
		hittracer = new("BridgeFindHitPointTracer");

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		Super.Tick();

		if (master)
		{
			pitch = master.pitch;
			if (master is "PortalSpot" && Distance3D(master) > 32.0) { Destroy(); }
		}
	}

	void A_FireBeam(int damage = 3, sound snd = "laser")
	{
		A_PlaySound(snd, 0, 1.0);

		DoBridgeTrace(self, angle, 2048, pitch, 0, 0, hittracer);
		DrawBridge(hittracer.Results);
	}

	action void DoBridgeTrace(Actor origin, double angle, double dist, double pitch, int flags, double zoffset, BridgeFindHitPointTracer thistracer)
	{
		if (!thistracer) { return; }

		if (!origin) { origin = self; }

		Vector3 tracedir = (cos(angle) * cos(pitch), sin(angle) * cos(pitch), -sin(pitch));
		thistracer.Trace(origin.pos + (0, 0, zoffset), origin.CurSector, tracedir, dist, 0);
	}

	void DrawBridge(TraceResults traceresults, Class<Actor> spawnclass = "BridgeBeam", double sparsity = 32.0)
	{
		if (!traceresults) { return; }

		int steps = int(traceresults.Distance / sparsity);

		Actor mo;
		Vector3 position = pos;

		for (int i = steps; i >= 0; i--)
		{
			mo = Spawn(spawnclass, position, ALLOW_REPLACE);
			if (mo)
			{
				mo.master = self;
				mo.pitch = pitch;
				mo.angle = angle;

				if (mo is "BridgeBeam") { BridgeBeam(mo).delay = level.time + i; }
			}

			position = pos + traceresults.HitVector * sparsity * i;
		}

		// Last one is decorative only and embedded in wall so the bridge always looks complete
		mo = Spawn(spawnclass, pos + traceresults.HitVector * sparsity * (steps + 1), ALLOW_REPLACE);
		if (mo)
		{
			mo.bNoInteraction = true;
			mo.bSolid = false;
			mo.master = self;
			mo.pitch = pitch;
			mo.angle = angle;

			if (mo is "BridgeBeam") { BridgeBeam(mo).delay = level.time + steps; }
		}

		if (!hitspot) { hitspot = Spawn("BridgeHitMarker", traceresults.HitPos, ALLOW_REPLACE); }
		if (hitspot)
		{
			hitspot.master = self;
		}
	}
}

class BridgeHitMarker : LaserHitMarker
{
	override void PostBeginPlay()
	{
		if (master)
		{
			Actor spot = Spawn("PortalMapSpot", pos + (RotateVector((1, 0), master.angle + 180), 24));
			if (spot)
			{
				spot.angle = master.angle + 180;
			}
		}

		Super.PostBeginPlay();
	}
}

class BridgeBeam : Actor
{
	Actor light;
	int delay;

	Default
	{
		+SOLID
		+NOGRAVITY
		Radius 8.0;
		Height 1;
		RenderStyle "Add";
		Alpha 0.0;
	}

	States
	{
		Spawn:
			UNKN A 5;
			Loop;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		A_PlaySound("bridge/loop", CHAN_6, 0.025, true, ATTN_STATIC);

		if (!light && !bNoInteraction)
		{
			light = Spawn("AlphaLight", pos);

			if (light)
			{
				light.master = self;
				DynamicLight(light).bAttenuate = true;
				AlphaLight(light).maxradius = 20.0;
				AlphaLight(light).clr = color("00 7B FF");
			}
		}
	}


	override void Tick()
	{
		Super.Tick();

		if (!master)
		{
			Destroy();
		}
		else if (level.time > delay)
		{
			alpha = 0.8 + 0.1 * sin(3 * level.time - Distance3D(master));
			if (light)
			{
				light.SetOrigin(pos, false);
				light.alpha = 0.5 + 0.4 * sin(3 * level.time - Distance3D(master));
				A_SoundVolume(CHAN_6, 0.0277 * light.alpha);
			}
		}
	}

	override void OnDestroy()
	{
		A_StopSound(CHAN_6);
		if (light) { light.Destroy(); }
	}
}

class BridgeEmitter : BridgeSpot
{
	Default
	{
		//$Category Portal/Objects
		//$Title Light Bridge Emitter
		-INVISIBLE
		Scale 1.2;
	}
}