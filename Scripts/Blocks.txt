class BlockBase : SwitchableDecoration
{
	Vector3 spawnoffset;
	Vector3 offset;
	int pushtime;
	double oldpitch;
	double oldroll;
	Vector3 oldpos;
	bool inrange;
	int interval;

	transient CVar debug;
	bool dodebug;

	Default
	{
		+NOGRAVITY
		+SOLID
		+SHOOTABLE
		+NOBLOOD
		+NOTAUTOAIMED
		+NODAMAGE
		+ALLOWPAIN
		+ACTLIKEBRIDGE
		+DONTTHRUST
		+INVISIBLE
		+THRUSPECIES
		Painchance 255;
		Radius 1;
		Height 1;
		Species "Block";
		RenderStyle "Add";
	}
	States
	{
		Spawn:
			UNKN A -1 BRIGHT;
			Stop;
	}

	override void PostBeginPlay()
	{
		debug = Cvar.FindCVar("g_debugblocks");

		if (debug && debug.GetBool())
		{
			dodebug = true;
			bInvisible = false;
		}

		if (master)
		{
			A_setSize(Radius * master.scale.x, Height * master.scale.y);
		}

		scale.x = Radius * 2.0;
		scale.y = Height * level.pixelStretch;

		if (master)
		{
			spawnoffset = pos - master.pos;

			Vector2 temp = RotateVector((spawnoffset.x, spawnoffset.y), -master.angle);
			offset = (temp.x, temp.y, spawnoffset.z);

			temp = RotateVector((offset.x, offset.z), master.pitch);
			offset = (temp.x, offset.y, temp.y);

			temp = RotateVector((offset.y, offset.z), -master.roll);
			offset = (offset.x, temp.x, temp.y);

			spawnoffset = offset;

			bSpecial = master.bPushable; // Only give SPECIAL if the master actor is pushable, since SPECIAL breaks collision.
		}

		interval = Random(0, 15);
	}

	override void Tick()
	{
		if (!master || master.bStandstill) { Destroy(); return; }

		if (level.time && (level.time + interval) % 15 == 0)
		{
			inrange = !CheckRange(max(256, master.renderradius * master.scale.x)); // Find any that are in range of a player
		}

		if (inrange)
		{
			if (master && !master.bNoInteraction)
			{
				Rotate();

				if (!bNoBlockMap && master.master && master.master is "PlayerPawn") { A_ChangeLinkFlags(1); }
				else if (bNoBlockMap) { A_ChangeLinkFlags(0); }
			}

			if (dodebug)
			{
				bBright = true;
				alpha = 0.95;
			}
			bNoInteraction = false;

			Super.Tick();
		}
		else
		{
			if (dodebug)
			{
				bBright = false;
				alpha = 0.1;
			}
			bNoInteraction = true;
		}
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (master)
		{
			master.DamageMobj(inflictor, source, damage, mod, flags, angle);
			return 0;
		}

		return Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}

	override void OnDestroy()
	{
		A_RemoveChildren(TRUE, RMVF_MISC, "None", "BlockBase");	
	}

	void Rotate()
	{
		if (!master || spawnoffset == (0, 0, 0) || (master.pitch == oldpitch && master.roll == oldroll && master.pos == oldpos)) { return; }

		Vector2 temp;

		// Keep the blocks in the correct position, regardless of pitch/roll of the master actor
		// Obviously not perfect, because the blocks are rectangular, but close enough when you can't see them.
		temp = RotateVector((spawnoffset.y, spawnoffset.z + height / 2), master.roll);
		offset = (spawnoffset.x, temp.x, temp.y);

		temp = RotateVector((offset.x, offset.z), -master.pitch);
		offset = (temp.x, offset.y, temp.y);

		temp = RotateVector((offset.x, offset.y), master.angle);
		offset = (temp.x, temp.y, offset.z - height / 2);

		Vector3 dest = master.pos + offset;
		SetOrigin(dest, true);

		pushtime++;

		oldpitch = master.pitch;
		oldroll = master.roll;
		oldpos = master.pos;

		angle = angle - (angle % 90); // Blocks are square, so keep the angles aligned with the grid for debug purposes
	}

	override void Touch(Actor toucher)
	{
		if (master && master.bPushable && toucher is "PlayerPawn")
		{
			master.lastpush = pushtime;
			master.vel = toucher.vel * master.pushfactor;

			Rotate();
		}
	}
}

class Block8x8 : BlockBase { Default { Radius 4; Height 8; } }
class Block32x1 : BlockBase { Default { Radius 16; Height 1; } }
class Block36x1 : BlockBase { Default { Radius 18; Height 1; } }
class Block42x42 : BlockBase { Default { Radius 21; Height 42; } }
class RailBlock : BlockBase { Default { Radius 1; Height 16; } }
class Step : BlockBase { Default { -SPECIAL; Radius 8; Height 1; } }

class DoorBlock : BlockBase
{
	Default
	{
		-SPECIAL;
		Radius 0;
		Height 64;
	}

	override void Tick()
	{
		Super.Tick();

		if (master && master is "Pivot" && Pivot(master).door) { angle = Pivot(master).door.angle; }
	}
}