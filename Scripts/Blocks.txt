class BlockBase : SwitchableDecoration
{
	Vector3 spawnoffset;
	Vector3 offset;
	int pushtime;
	double oldpitch;
	double oldroll;
	Vector3 oldpos;
	bool inrange;

	Default
	{
		+NOGRAVITY
		+SOLID
		+SHOOTABLE
		+NOBLOOD
		+NOTAUTOAIMED
		+NODAMAGE
		+ALLOWPAIN
		+ACTLIKEBRIDGE
		+DONTTHRUST
		+INVISIBLE
		+THRUSPECIES
		Painchance 255;
		Radius 1;
		Height 1;
		Scale 0.1;
		Species "Block";
	}
	States
	{
		Spawn:
			UNKN A -1 BRIGHT;
			Stop;
	}

	override void PostBeginPlay()
	{
		CVar debug = Cvar.FindCVar("g_debugblocks");

		if (debug && debug.GetBool()) { bInvisible = false; }

		if (master)
		{
			spawnoffset = pos - master.pos;

			Vector2 temp = RotateVector((spawnoffset.x, spawnoffset.y), -master.angle);
			spawnoffset = (temp.x, temp.y, spawnoffset.z);

			offset = spawnoffset;

			scale.x *= master.scale.x;
			scale.y *= master.scale.y;

			bSpecial = master.bPushable; // Only give SPECIAL if the master actor is pushable, since SPECIAL breaks collision.
		}
	}

	override void Tick()
	{
		Super.Tick();

		if (!master) { Destroy(); return; }

		if (master.master && master.master is "PlayerPawn") { A_ChangeLinkFlags(1); }
		else if (bNoBlockMap) { A_ChangeLinkFlags(0); }

		if (level.time && level.time % 15 == 0 && master)
		{
			inrange = InPlayerSightorRange(master, 128);
		}

		if (inrange && !master.bNoInteraction) { Rotate(); }
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (master)
		{
			master.DamageMobj(inflictor, source, damage, mod, flags, angle);
			return 0;
		}

		return Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}

	override void OnDestroy()
	{
		A_RemoveChildren(TRUE, RMVF_MISC, "None", "BlockBase");	
	}

	void Rotate()
	{
		if (pitch == oldpitch && roll == oldroll && master.pos == oldpos) { return; }

		Vector2 temp;

		// Keep the blocks in the correct position, regardless of pitch/roll of the master actor
		// Obviously not perfect, because the blocks are rectangular, but close enough when you can't see them.
		if (master && spawnoffset != (0, 0, 0)) {
			temp = RotateVector((spawnoffset.y, spawnoffset.z), master.roll);
			offset = (spawnoffset.x, temp.x, temp.y);

			temp = RotateVector((offset.x, offset.z), 360 - master.pitch);
			offset = (temp.x, offset.y, temp.y);

			temp = RotateVector((offset.x, offset.y), master.angle);
			offset = (temp.x, temp.y, offset.z);

			offset.x *= master.scale.x;
			offset.y *= master.scale.x;
			offset.z *= master.scale.y;

			Vector3 dest = master.pos + offset;
			SetOrigin(dest, true);

			pushtime++;
		}

		oldpitch = pitch;
		oldroll = roll;
		oldpos = master.pos;
	}

	override void Touch(Actor toucher)
	{
		if (master && master.bPushable && toucher is "PlayerPawn")
		{
			master.lastpush = pushtime;
			master.vel = toucher.vel * master.pushfactor;

			Rotate();
		}
	}

	bool InPlayerSightorRange(Actor sighttarget = null, int range = 0)
	{
		if (!sighttarget) { sighttarget = self; }

		for (int p = 0; p < MAXPLAYERS; p++) // Iterate through all of the players and see if any can see the spawn point
		{
			Actor mo = players[p].mo;

			if (mo) {
				if (
					mo.CheckSight(sighttarget, SF_SEEPASTBLOCKEVERYTHING | SF_SEEPASTSHOOTABLELINES) && (!range || sighttarget.Distance2D(mo) <= range)
				) { return true; }
			}
		}

		return false;
	}
}

class Block8x8 : BlockBase { Default { Radius 4; Height 8; } }
class Block32x1 : BlockBase { Default { Radius 16; Height 1; } }
class Block36x1 : BlockBase { Default { Radius 18; Height 1; } }
class Block42x42 : BlockBase { Default { Radius 21; Height 42; } }
class RailBlock : BlockBase { Default { Radius 1; Height 16; } }
class Step : BlockBase { Default { -SPECIAL; Radius 8; Height 1; } }

class DoorBlock : BlockBase
{
	Default
	{
		-SPECIAL;
		Radius 0;
		Height 64;
	}

	override void Tick()
	{
		Super.Tick();

		if (master && master is "Pivot" && Pivot(master).door) { angle = Pivot(master).door.angle; }
	}
}