class PortalActor : Actor
{
	int user_variant;
	bool user_blockingrails;
	String stepsound;

	Property StepSound:stepsound;

	States
	{
		Spawn:
			UNKN A -1;
			Stop;
	}

	override void PostBeginPlay()
	{
		bDormant = SpawnFlags & MTF_DORMANT;
		bNoGravity = bStandStill ? true : Default.bNoGravity;
		bNoInteraction = bStandStill ? false : Default.bNoInteraction;
		bSolid = bStandStill ? false : Default.bSolid;

		if (!bSolid && bNoInteraction) { A_SetSize(0, 0); }
		else
		{
			A_SetSize(radius * scale.x, height * scale.y); // This sets based on UDMF scale properties
			mass = int(mass * scale.x);
		}

		if (!bStandStill) { SpawnBlocks(); }

		frame = user_variant;

		Super.PostBeginPlay();
	}

	void OffsetRelative(Actor mo, double xoffset = 0, double yoffset = 0, double zoffset = 0)
	{
		if (!mo) { return; }

		Vector2 temp;
		Vector3 offset;

		temp = RotateVector((yoffset, zoffset), roll);
		offset = (xoffset, temp.x, temp.y);

		temp = RotateVector((offset.x, offset.z), -pitch);
		offset = (temp.x, offset.y, temp.y);

		temp = RotateVector((offset.x, offset.y), angle);
		offset = (temp.x, temp.y, offset.z);

		offset.x *= scale.x;
		offset.y *= scale.x;
		offset.z *= scale.y;

		mo.SetOrigin(pos + offset, true);
	}

	virtual void SpawnBlocks() {}
}

class CarryActor : PortalActor
{
	Vector3 oldpos;
	double oldangle;
	double spawnheight, spawnradius;
	Sound slidesound;
	Array<Actor> touchers;
	Vector3[64] offsets;
	bool fizzle, explode;
	int offset, fizzletime;
	bool crushed;
	bool initialized;
	int waterstate;
	double zoffset;

	Property SlideSound:slidesound;
	Property Fizzle:fizzle;
	Property Explode:explode;

	Default
	{
		//$Category Portal/Objects/Carryable
		+ALLOWBOUNCEONACTORS
		+BOUNCEONACTORS
		+MBFBOUNCER
		+BOUNCEAUTOOFF
		+SLIDESONWALLS
		+PUSHABLE
		+WINDTHRUST
		+SOLID
		+CANPASS
		+SHOOTABLE
		+NOBLOOD
		+NOTAUTOAIMED
		+NODAMAGE
		BounceType "Grenade";
		BounceFactor 0.25;
		BounceSound "cube/bounce";
		WallBounceSound "cube/bounce";
		Health 35;
		CarryActor.SlideSound "cube/slide";
		CarryActor.Fizzle False;
		CarryActor.Explode False;
	}

	States
	{
		Fizzle:
			UNKN A 1;
			UNKN A 0 {
				Utilities.Fizzle(self);

				if (fizzletime++ < 70) { SetStateLabel("Fizzle"); }
			}
			Stop;
		Death:
			UNKN # 1 {
				if (explode) { SetStateLabel("Death.Explode"); }
				A_NoBlocking();
			}
			UNKN # -1;
			Stop;
		Death.Crush:
			UNKN # 1;
			UNKN # 0 {
				if (explode) { SetStateLabel("Death.Explode"); }
/*
				else if (scale.y * spawnheight > 9.0)
				{
					double newscale = (ceilingz - floorz) / spawnheight;
					if (newscale < scale.y)
					{
						scale.y = newscale;
						scale.x = max(1.0, 1.0 / (newscale * 3));
						A_SetSize(spawnradius * scale.x, spawnheight * scale.y);
					}

					SetStateLabel("Death.Crush");
				}
*/
			}
			UNKN # -1;
			Stop;
		Death.Explode:
			UNKN # 4 {
				Actor debris = Spawn("DebrisSpawner", pos);
				if (debris) { debris.master = self; }

				bNoGravity = true;
				scale.y *= 0.9;
				scale.x *= 1.1;
				SetOrigin(pos + (0, 0, 0.2 * height), true);

				frame++;
			}
			UNKN # 2 {
				scale.y *= 0.8;
				scale.x *= 1.2;
				SetOrigin(pos + (0, 0, 0.4 * height), true);

				Actor explosion = Spawn("Explosion", pos);
				if (explosion) { explosion.master = self; }
			}
			Stop;
	}

	override void BeginPlay()
	{
		A_SetSize(radius * scale.x, height * scale.y); // This sets based on Default scale properties
		offset = Random(0, 35);
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();

		spawnheight = height;
		spawnradius = radius;

		bPushable = !bStandStill && !bDormant;

		pushfactor = double(100) / mass;

		if (scale.x > 1.5 || scale.y > 1.5) { bPushable = false; }

		gravity = 0.5;
	}

	override void Tick()
	{
		if (IsFrozen()) { return; }

		if (!initialized && level.time - SpawnTime > 35 && vel.length() == 0)
		{
			gravity = Default.gravity;
			initialized = true;
		}

		if (!bNoGravity && !master || !(master is "PlayerPawn")) { zoffset = Utilities.SetPitchRoll(self); }

		if (!fizzle && pos.z == floorz && floorpic == TexMan.CheckForTexture("F_SKY1", TexMan.Type_Any))
		{
			ClearBounce();

			scale *= 0.9;

			if (Scale.X < 0.05) { Destroy(); return; }
		}

		if (master is "Launcher")
		{
			if (!vel.z || pos.z == ceilingz - height)
			{
				gravity = Default.gravity;
				master = null;
			}
		}

		// Handling so that bounce sound doesn't play if the object didn't move 
		// or when it's being carried, and so that the angle doesn't stutter when
		// the object is pushed but cannnot move.
		if (pos == oldpos || (master is "PlayerPawn") || waterlevel)
		{
			bNoBounceSound = true;
		}
		else
		{
			bNoBounceSound = false;
		}

		oldpos = pos;
		oldangle = angle;

		// Stackable movable objects
		if ((level.time + offset) % 10 == 0) { CheckTouchers(); }

		if (fizzle) { Utilities.CheckFizzle(self, "Fizzle"); }
		else
		{
			// One-time water entry/exit splashes
			if (waterlevel > 1 && !waterstate) { A_StartSound("world/water/enter", CHAN_AUTO, 0, 0.5 * vel.length()); }
			else if (!waterlevel && waterstate > 1) { A_StartSound("world/water/exit", CHAN_AUTO, 0, 0.5 * vel.length(), false, ATTN_NORM, false); }

			waterstate = waterlevel;
		}

		for (int i = 0; i < min(touchers.Size(), 64); i++)
		{
			if (touchers[i] && touchers[i] != master)
			{
				if (
					Distance3D(touchers[i]) > (Radius + touchers[i].radius) * 2.0 ||
					touchers[i].pos.z < pos.z + height
				) { touchers.Delete(i); }
				else { offsets[i] = touchers[i].pos - pos; }
			}
			else { touchers.Delete(i); touchers.ShrinkToFit(); }
		}

		Super.Tick();

		if (master && master is "PortalPlayer")
		{
			if (PortalPlayer(master).DragTarget == self) { vel = PortalPlayer(master).dragvel; }

		}

		for (int i = 0; i < min(touchers.Size(), 64); i++)
		{
			if (
				touchers[i] && 
				(
					(Distance2D(touchers[i]) < (Radius + touchers[i].radius) * 1.4 && touchers[i].pos.z == pos.z + height) ||
					deltaangle(angle, AngleTo(touchers[i])) < 45 ||
					(touchers[i].bOnMobj && Distance3D(touchers[i]) < radius * 2)
				)
			)
			{
				if (!(touchers[i] is "PlayerPawn") && touchers[i].pos.z == pos.z + height) { touchers[i].vel = vel; }
				else if (touchers[i].CheckMove(pos.xy + offsets[i].xy)) { touchers[i].SetOrigin(pos + offsets[i], true); }
				else if (touchers[i].pos.z < pos.z + height) { touchers[i].DamageMobj(self, self, int(max(Speed, 0.5) * vel.length()), "Crush"); }
			}
		}
/*
		if (zoffset)
		{
			if (pos.z <= floorz + zoffset)
			{
				vel *= 0;
				bNoGravity = true;
				SetOrigin((pos.xy, floorz + zoffset), false);
			}
			else
			{
				bNoGravity = Default.bNoGravity;
			}
		}
*/

		angle = oldangle;

		if (bNoBounceSound && oldangle) { angle = oldangle; }

		double volume = 0.0;

		if (health > 0 && (pos.z <= floorz + zoffset) && !waterlevel) { volume = vel.xy.length() / 25; }

		if (volume)
		{
			A_StartSound(slidesound, CHAN_5, CHANF_LOOP | CHANF_NOSTOP, volume);
			A_SoundVolume(CHAN_5, volume);
		}
		else
		{
			A_StopSound(CHAN_5);
		}
	}

	override void Touch(Actor toucher)
	{
		if (Distance2D(toucher) > Radius + toucher.Radius) { return; }
		if (toucher == self || toucher == toucher.master || toucher.bNoGravity) { return; }
		if (toucher.pos.z > pos.z + height + 32.0 || toucher.pos.z <= pos.z) { return; }
		if (touchers.Find(toucher) == touchers.Size()) { touchers.Push(toucher); }
	}

	void CheckTouchers()
	{
		BlockThingsIterator it = BlockThingsIterator.Create(self, Radius);
		Actor mo;

		while (it.Next() && (mo = it.thing))
		{
			if (mo is "PlayerPawn") { continue; }
			if (mo.bSolid && !mo.bNoInteraction && (mo.bPushable || mo is "CarryActor")) { Touch(mo); }
		}
	}

	override void OnDestroy()
	{
		A_StopSound(CHAN_5);
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (mod == "Crush" || mod == "Fizzle" || explode)
		{
			if (mod == "Crush" && scale.y * spawnheight > 9.0)
			{
				double newscale = (ceilingz - floorz) / spawnheight;
				if (newscale < scale.y)
				{
					scale.y = newscale;
					scale.x = max(1.0, 1.0 / (newscale * 3));
					A_SetSize(spawnradius * scale.x, spawnheight * scale.y);
				}
			}

			if (explode) { return Super.DamageMobj(inflictor, source, damage, mod, flags, angle); }
		}

		return 0;
	}
}