class PortalGun : Weapon
{
	Actor portalA, portalB;
	bool dual, cleared, shottype;
	
	PortalFindHitPointTracer portaltracer;

	Property Dual:dual;

	Default
	{
		//$Category Portal/Objects
		//$Title Portal Gun (Blue Only)
		+WEAPON.CHEATNOTWEAPON
		Weapon.SelectionOrder 1;
		Weapon.AmmoUse 0;
		Weapon.UpSound "portalgun/up";
		Weapon.ReadySound "";
		Inventory.Pickupmessage "$PORTALGUNPICKUP";
		Inventory.PickupSound "";
		Tag "$PORTALGUNTAG";
		Weapon.BobSpeed 0.7;
		Weapon.BobStyle "Alpha";
	}

	States
	{
		Ready:
			PGUN A 0 { if (invoker.shottype) { return ResolveState("Ready.Orange"); } return ResolveState(null); }
			Ready.Blue:
				PGUN A 1 A_PortalWeaponReady;
				Loop;
			Ready.Orange:
				PGU2 A 1 A_PortalWeaponReady;
				Loop;
		Deselect:
			PGUN A 0 { if (invoker.shottype) { return ResolveState("Deselect.Orange"); } return ResolveState(null); }
			Deselect.Blue:
				PGUN A 1 A_Lower;
				Loop;
			Deselect.Orange:
				PGU2 A 1 A_Lower;
				Loop;
		Select:
			PGUN A 1 A_Raise;
			Loop;
		Fire:
			PGUN B 2;
			PGUN C 3 A_FirePortalGun;
			PGUN DE 3 A_Refire;
			Goto Ready;
		AltFire:
			PGUN A 0 { if (!invoker.dual) { return ResolveState("Fire"); } return ResolveState(null); }
			PGU2 B 2;
			PGU2 C 3 A_FirePortalGun;
			PGU2 DE 3 A_Refire;
			Goto Ready;
		Hold:
			PGUN A 1;
			PGUN A 0 A_Refire;
			Goto Ready;
		AltHold:
			PGUN A 0 { if (!invoker.dual) { return ResolveState("Hold"); } return ResolveState(null); }
			PGU2 A 1;
			PGU2 A 0 A_Refire;
			Goto Ready;
 		Spawn:
			PGUN S -1;
			Stop;
		Shake:
			PGUN A 0 { if (invoker.shottype) { return ResolveState("Shake.Orange"); } return ResolveState(null); }
			Shake.Blue:
				PGUN FG 5;
				Goto Ready;
			Shake.Orange:
				PGU2 FG 5;
				Goto Ready;
	}

	override void BeginPlay()
	{
		ChangeStatNum(Thinker.STAT_USER);
	}

	override void PostBeginPlay()
	{
		portaltracer = new("PortalFindHitPointTracer");

		bNoGravity = bStandStill;

		Super.PostBeginPlay();
	}

	action void A_PortalWeaponReady()
	{
		int flags = 0;

		if (player && player.mo)
		{
			if (PortalPlayer(player.mo) && PortalPlayer(player.mo).DragTarget) { flags = WRF_NOFIRE; }
		}

		A_WeaponReady(flags);
	}

	action void A_FirePortalGun()
	{
		if (player)
		{
			Weapon weap = player.ReadyWeapon;
			if (weap != null && invoker == weap && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
			{
				if (!weap.DepleteAmmo(weap.bAltFire, true, 1)) { return; }
				player.SetPsprite(PSP_FLASH, weap.FindState('Flash'), true);
			}

			player.mo.PlayAttacking2();
		}

		if (invoker.dual && player.ReadyWeapon && player.ReadyWeapon.bAltFire) { A_PlaySound("portalgun/fire2", CHAN_WEAPON); invoker.shottype = 1; }
		else { A_PlaySound("portalgun/fire1", CHAN_WEAPON); invoker.shottype = 0; }

		DoTrace(self, angle, 2048, pitch, 0, player.viewheight, invoker.portaltracer);

		int type = invoker.portaltracer.Results.HitType;

		Actor portal = Spawn("PortalSpot", invoker.portaltracer.Results.HitPos);

		if (portal)
		{
			portal.master = self;
			portal.ChangeTID(9990 + PlayerNumber());

			Vector3 snappos = invoker.portaltracer.Results.HitPos;
			snappos.x = invoker.RoundToMultiple(snappos.x, 16.0);
			snappos.y = invoker.RoundToMultiple(snappos.y, 16.0);
			snappos.z = invoker.RoundToMultiple(snappos.z, 16.0);

			if (type == TRACE_HitWall)
			{
				Line linedef = invoker.portaltracer.Results.HitLine;
				double lineangle;

				if (!linedef.delta.x) { lineangle = 0; }
				else if (!linedef.delta.y) { lineangle = 90; }
				else { lineangle = (atan(linedef.delta.y / linedef.delta.x) + 270) % 360; }

				if (abs(deltaangle(lineangle, portal.AngleTo(self))) > 90) { lineangle += 180; }

				portal.angle = lineangle;

				portal.SetOrigin(portal.pos + AngleToVector(portal.AngleTo(self), 1), false); // Offset from the wall slightly to avoid z-fighting
				PortalSpot(portal).snappos = snappos + AngleToVector(portal.AngleTo(self), 1);
				PortalSpot(portal).shotpos = invoker.portaltracer.Results.HitPos + AngleToVector(portal.AngleTo(self), 1);
				PortalSpot(portal).linedef = linedef; // Save the linedef and angle for reference later (so portals can be destroyed if the surface moves)
				PortalSpot(portal).lineangle = lineangle;
			}
			else
			{
				portal.angle = portal.AngleTo(self);

				if (type == TRACE_HitFloor || type == TRACE_HitCeiling)
				{
					secplane splane;
					Vector3 normal;
					int zoffset;

					if (type == TRACE_HitFloor)
					{
						splane = invoker.portaltracer.Results.HitSector.floorplane;
						normal = splane.normal;
						zoffset = 2;
					}
					else if (type == TRACE_HitCeiling)
					{
						splane = invoker.portaltracer.Results.HitSector.ceilingplane;
						normal = splane.normal;
						zoffset = -2;
					}

					portal.pitch = -atan2(normal.z, normal.xy.length());

					PortalSpot(portal).slopeangle = atan2(normal.y, normal.x);
					if (portal.pitch % 90) { portal.angle = PortalSpot(portal).slopeangle; } // Automatically align portals on slopes to the slope direction

					portal.SetOrigin(portal.pos + (0, 0, zoffset), false);
					PortalSpot(portal).shotpos = invoker.portaltracer.Results.HitPos + (0, 0, zoffset);
					PortalSpot(portal).snappos = snappos;
				}
			}

			if (player && player.ReadyWeapon.bAltFire && invoker.dual)
			{
				invoker.PortalSetup(PortalSpot(portal), 1);
			}
			else
			{
				invoker.PortalSetup(PortalSpot(portal), 0);

				ThinkerIterator it = ThinkerIterator.Create("StaticPortalSpot", Thinker.STAT_USER + 1);
				PortalSpot mo;

				if (mo = PortalSpot(it.Next(true)))
				{
					invoker.PortalSetup(mo, 1, false);
				}
			}

			if (portal.waterlevel) { PortalSpot(portal).pair = portal; }
		}
	}

	void PortalSetup(PortalSpot portal, int frame, bool destroyold = true)
	{
		portal.frame = frame;
		portal.pair = frame ? portalA : portalB;

		int index;
		if (owner) { index = owner.PlayerNumber() + 1; }

		portal.camtex = "PORTAL" .. index .. (frame ? "A" : "B");

		SpriteID spr = GetSpriteIndex("POR" .. index);
		if (spr) { portal.sprite = spr; }

		if (portal.pair) { PortalSpot(portal.pair).pair = portal; }

		if (frame)
		{
/*
			if (destroyold && PortalSpot(portal) && PortalSpot(portal).CheckSpawn())
			{
				PortalSpot(portalB).replacement = portal;
				portalB = portal;
			}
*/
			if (portalB && destroyold) { PortalSpot(portalB).replacement = portal; }
			portalB = portal;
		}
		else
		{
/*
			if (destroyold && PortalSpot(portal) && PortalSpot(portal).CheckSpawn())
			{
				PortalSpot(portalA).replacement = portal;
				portalA = portal;
			}
*/
			if (portalA && destroyold) { PortalSpot(portalA).replacement = portal; }
			portalA = portal;
		}
	}

	double RoundToMultiple(double i, double n)
	{
		return (i % n) > (n / 2) ? i + n - (i % n) : i - (i % n);
	}

	action void DoTrace(Actor origin, double angle, double dist, double pitch, int flags, double zoffset, PortalFindHitPointTracer thistracer)
	{
		if (!origin) { origin = self; }

		thistracer.skipspecies = origin.species;
		thistracer.skipactor = origin;

		Vector3 tracedir = (cos(angle) * cos(pitch), sin(angle) * cos(pitch), -sin(pitch));
		thistracer.Trace(origin.pos + (0, 0, zoffset), origin.CurSector, tracedir, dist, 0);
	}
}

class DualPortalGun : PortalGun
{
	Default
	{
		//$Title Portal Gun
		-WEAPON.CHEATNOTWEAPON // Give this one by default with cheat (works in all cases, even with static portals)
		Inventory.Pickupmessage "$PORTALGUNPICKUP2";
		Tag "$PORTALGUNTAG2";
		PortalGun.Dual true;
	}
}